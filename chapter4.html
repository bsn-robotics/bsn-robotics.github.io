<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <link rel="stylesheet" href="style.css" type="text/css">
    <title>4chapter</title>
  </head>
  <body><page size="A4">
      <h1>4 Практическая реализация разработанных алгоритмов</h1>
      <br>
      <!--Диссертация 1 стр 136-->
      <p>Последняя глава диссертации посвящена исследованию навигационной
        системы путем моделирования и с помощью экспериментальных исследований.
        Для этого был разработан пакет программ, который включает в себя ПО
        навигационной системы, драйвер мобильного робота и среду моделирования;
        кроме того, для проведения экспериментов был изготовлен действующий
        макет мобильного робота.<br>
        В навигационной системе реализованы алгоритмы, которые подробно
        рассмотрены в предыдущих главах настоящей диссертационной работы.
        Драйвер мобильного робота служит для получения данных от лазерного
        дальномера и выдачи сигналов управления на приводной уровень<br>
        мобильного робота. Среда моделирования предназначена для<br>
        отладки ПО навигационной системы и исследования алгоритмов навигации
        мобильного робота. Эксперимент позволил подтвердить работоспособность
        каждого алгоритма навигации мобильного робота и системы в целом. Для
        этого был разработан макет мобильного робота,<br>
        однако для повышения достоверности результатов, было проведено несколько
        экспериментов на различных мобильных роботах.</p>
      <!--Диссертация 1 стр 136 конец-->
      <h2>4.1 Робототехническая платформа для испытания разработанных алгоритмов</h2>
      <p>Робот представляет собой трехколесную платформу собственной разработки,
        основой платформы является гироскутер “Smartbalance 10”. Два колеса
        ведущие, третье колесо ведомое (см. рисунки 15, 16). Характеристики
        платформы приведены в таблице 1.</p>
      <p><img style="width: 488px; height: 324px;" longdesc="02" title="02" alt="02"
          src="img/chapter4_02.JPG"></p>
      <p>Рисунок 15 – Внешний вид робототехнической платформы сзади</p>
      <p><img style="width: 489px; height: 326px;" longdesc="01" title="01" alt="01"
          src="img/chapter4_01.JPG"></p>
      <p>Рисунок 16 – Внешний вид робототехнической платформы спереди</p>
      <p>Платформа оснащена бортовым аккумулятором напряжением 36 В для питания
        двух электродвигателей гироскутера, а также аккумулятором 12 В для
        питания времепролетной камеры Kinect 2.0. </p>
      <p>Таблица 1—Характеристики платформы собственной разработки</p>
      <p><br>
      </p>
      <br>
      <table cellpadding="7" cellspacing="0" width="657">
        <colgroup><col width="313"> <col width="313"> </colgroup>
        <tbody>
          <tr valign="top">
            <td style="border: 1px solid #000001; padding-top: 0in; padding-bottom: 0in; padding-left: 0.08in; padding-right: 0.08in"
              width="313">
              <p class="western" style="margin-right: 0in; widows: 2; orphans: 2"
                align="justify"> <font color="#000000"><font face="Times New Roman, serif"><font
                      style="font-size: 14pt" size="4">Габаритные размеры</font></font></font></p>
            </td>
            <td style="border: 1px solid #000001; padding-top: 0in; padding-bottom: 0in; padding-left: 0.08in; padding-right: 0.08in"
              width="313">
              <p class="western" style="margin-right: 0in; widows: 2; orphans: 2"
                align="justify"> <font color="#000000"><font face="Times New Roman, serif"><font
                      style="font-size: 14pt" size="4"><span lang="en-US">600</span>
                      <span lang="en-US">x 600 x 400 </span>мм</font></font></font></p>
            </td>
          </tr>
          <tr valign="top">
            <td style="border: 1px solid #000001; padding-top: 0in; padding-bottom: 0in; padding-left: 0.08in; padding-right: 0.08in"
              width="313">
              <p class="western" style="margin-right: 0in; widows: 2; orphans: 2"
                align="justify"> <font color="#000000"><font face="Times New Roman, serif"><font
                      style="font-size: 14pt" size="4">Масса</font></font></font></p>
            </td>
            <td style="border: 1px solid #000001; padding-top: 0in; padding-bottom: 0in; padding-left: 0.08in; padding-right: 0.08in"
              width="313">
              <p class="western" style="margin-right: 0in; widows: 2; orphans: 2"
                align="justify"> <font color="#000000"><font face="Times New Roman, serif"><font
                      style="font-size: 14pt" size="4">14 кг</font></font></font></p>
            </td>
          </tr>
          <tr valign="top">
            <td style="border: 1px solid #000001; padding-top: 0in; padding-bottom: 0in; padding-left: 0.08in; padding-right: 0.08in"
              width="313">
              <p class="western" style="margin-right: 0in; widows: 2; orphans: 2"
                align="justify"> <font color="#000000"><font face="Times New Roman, serif"><font
                      style="font-size: 14pt" size="4">Максимальная скорость
                      перемещения</font></font></font></p>
            </td>
            <td style="border: 1px solid #000001; padding-top: 0in; padding-bottom: 0in; padding-left: 0.08in; padding-right: 0.08in"
              width="313">
              <p class="western" style="margin-right: 0in; widows: 2; orphans: 2"
                align="justify"> <font color="#000000"><font face="Times New Roman, serif"><font
                      style="font-size: 14pt" size="4">2 м<span lang="en-US">/c</span></font></font></font></p>
            </td>
          </tr>
          <tr valign="top">
            <td style="border: 1px solid #000001; padding-top: 0in; padding-bottom: 0in; padding-left: 0.08in; padding-right: 0.08in"
              width="313">
              <p class="western" style="margin-right: 0in; widows: 2; orphans: 2"
                align="justify"> <font color="#000000"><font face="Times New Roman, serif"><font
                      style="font-size: 14pt" size="4">Максимальное время
                      автономной работы </font></font></font> </p>
            </td>
            <td style="border: 1px solid #000001; padding-top: 0in; padding-bottom: 0in; padding-left: 0.08in; padding-right: 0.08in"
              width="313">
              <p class="western" style="margin-right: 0in; widows: 2; orphans: 2"
                align="justify"> <font color="#000000"><font face="Times New Roman, serif"><font
                      style="font-size: 14pt" size="4">4 ч</font></font></font></p>
            </td>
          </tr>
          <tr valign="top">
            <td style="border: 1px solid #000001; padding-top: 0in; padding-bottom: 0in; padding-left: 0.08in; padding-right: 0.08in"
              width="313">
              <p class="western" style="margin-right: 0in; widows: 2; orphans: 2"
                align="justify"> <font color="#000000"><font face="Times New Roman, serif"><font
                      style="font-size: 14pt" size="4">Грузоподъемность</font></font></font></p>
            </td>
            <td style="border: 1px solid #000001; padding-top: 0in; padding-bottom: 0in; padding-left: 0.08in; padding-right: 0.08in"
              width="313">
              <p class="western" style="margin-right: 0in; widows: 2; orphans: 2"
                align="justify"> <font color="#000000"><font face="Times New Roman, serif"><font
                      style="font-size: 14pt" size="4">15 кг</font></font></font></p>
            </td>
          </tr>
        </tbody>
      </table>
      <p><br>
      </p>
      <p>К гироскутеру присоединяется рама (см. рисунок 17), разработанная для
        крепления третьего ведомого колеса, аккумулятора, а также профильной
        панели. На панели крепятся бортовая ЭВМ, стойка с времепролетной
        камерой, контроллер двигателей, переходник для питания камеры.</p>
      <p><img style="width: 477px; height: 316px;" title="03" alt="03" src="img/chapter4_03.JPG"></p>
      <p>Рисунок 17 - Внешний вид рамы </p>
      <p>Непосредственно на гироскутере установлена электронная плата
        собственной разработки - коммутатор (см. пункт 4.2.1 настоящей работы).
        Коммутатор предназначен для коммутации силовых проводов.</p>
      <h3>4.1.1Анализ работы гироскутера.</h3>
      <p>На рис. представлен общий вид гироскутера.</p>
      <p><img style="width: 572px; height: 272px;" longdesc="1" title="1" alt="1"
          src="img/chapter4_1.jpg"></p>
      <p>Рисунок 18 - Внешний вид гироскутера</p>
      <p>На рис. представлена общая <a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%B0%D1%8F_%D1%81%D1%85%D0%B5%D0%BC%D0%B0">структурная</a>
        схема устройства гироскутера.</p>
      <p><img style="width: 560px; height: 282px;" longdesc="2" title="2" alt="2"
          src="img/chapter4_2.png"></p>
      <p>Рисунок 19 - Общая структурная схема устройства гироскутера</p>
      <p>Для того чтобы иметь возможность управлять гироскутером, используя внешний
        блок управления, был применен метод описанный в статье [], позволяющий с
        помощью логического анализатора <a style="color: red;" href="%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C">(модель
          и программа)</a> проанализировать протокол обмена данными между
        платами гироскопов и основной платой гироскутера. Программа для работы с
        логическим анализатором интерпретирует низкий и высокий логический
        уровни, как передаваемые биты дан.</p>
      <!--Протокол(интерфейс) UART (Universal asynchronous receiver/transmitter) или УАПП (универсальный асинхронный приемопередатчик).-->
      <p>С помощью программы была получена диаграмма передаваемых с платы
        гироскопа данных (см. рисунок 20) и идентифицирован протокол их
        передачи.</p>
      <p>Протокол представляет собой <a href="https://geektimes.ru/post/253786/">UART</a>
        RS-232. Данные передаются <a href="http://ooep.kpi.ua/microcontrollers/rus/Downloads/LabWork_5.pdf">пакетами</a>
        по 9 бит. Диаграмма, передаваемых по протоколу данных, представлена на
        рисунке 20. На диаграмме видна последовательность передаваемых пакетов.</p>
      <p><img style="width: 606px; height: 90px;" title="10" alt="10" src="img/chapter3_10_datagram1.PNG"></p>
      <p>Рисунок 20 -&nbsp; Диаграмма, полученная с помощью программы</p>
      <p><br>
      </p>
      <p>На рисунке 21 представлена передача последнего пакета из последовательности
        пакетов представленных на рисунке 20, на диаграмме (см. рисунок 21) видно
        что пакет состоит из стартового бита,&nbsp; 9 бит, кодирующих число 170
        и одного стоп-бита. </p>
      <p><br>
      </p>
      <p><img style="width: 599px; height: 102px;" title="11" alt="11" src="img/chapter3_11_datagram2.PNG"></p>
      <p>Рисунок 21 - Диаграмма передачи одного пакета</p>
      <p><br>
      </p>
      <p>В таблице 3 представлены характеристики протокола, определенные с
        помощью программы.</p>
      <p><br>
      </p>
      <p>С помощью описанного выше метода было установлено, что каждые 300 мкс
        циклически повторяется следующая последовательность пакетов:</p>
      <p> </p>
      <ol>
        <li>Команда разрешения. Имеет два значения - 170, при этом число,
          кодирующее угол наклона платы гироскопа, игнорируется в дальнейшем
          основной платой гироскутера. Значение - 85, при этом число, кодирующее
          угол наклона платы гироскопа, обрабатывается основной платой
          гироскутера.</li>
        <li>Фиксированное число 0</li>
        <li>Фиксированное число 0</li>
        <li>Фиксированное число 256</li>
        <li>Младшие 9 бит числа, кодирующего угол наклона платы гироскопа.</li>
        <li>Старшие 9 бит числа, кодирующего угол наклона.</li>
        <li>Повтор младших бит числа, кодирующего угол наклона.</li>
        <li>Повтор старших бит числа, кодирующего угол наклона.</li>
      </ol>
      <p>Угол наклона платы гироскопа прямопропорционален скважности ШИМ
        (Широтно-импульсная модуляция) сигнала, подающегося на обмотки
        электродвигателя, а следовательно угол наклона прямопропорционален и
        скорости вращения двигателя. </p>
      <p>Угол наклона задается 18-битным целым числом.</p>
      <p>Изменение угла наклоны платы, показано на рис.</p>
      <p>При анализе работы гироскутера замечены особенности управления, и
        выделены два режима работы:</p>
      <p>1. При задании угла наклона одного знака с обоих плат гироскопов,
        скорость двигателей достигает пропорциональной углу наклона, после чего
        через несколько секунд двигатели начинают ускоряться до максимально
        возможной скорости. Если угол наклона сохраняется то, скорость
        двигателей увеличивается чтобы компенсировать, наклон человека,
        управляющего гироскутером или чтобы увеличить скорость движения вперед.</p>
      <p>2. При задании угла наклона разного знака, скорость каждого из
        двигателей достигает скорости, пропорциональной углу наклона и остается
        неизменной.</p>
      <p>Проведенный анализ работы гироскутера показал, что стабильное
        управление гироскутером с помощью задания угла наклона, возможно только
        при втором режиме работы, когда углы наклона плат гироскопов имеют
        разные знаки и двигатели вращаются в разные стороны.</p>
      <p>Возникает проблема управления гироскутером при движении вперед и назад.</p>
      <h3>4.1.2 Модификация гироскутера.</h3>
      <p>Платы гироскопов были удалены. Вместо них для подачи команд управления
        на основную плату гироскутера и имитирования сигналов с плат гироскопов
        была установлена плата с микроконтроллером STM32, соединенная с бортовой
        ЭВМ по интерфейсу UART RS-232 8 bit.</p>
      <p>Для решения проблемы управления гироскутером при движении вперед и
        назад разработана электронная плата - коммутатор, аппаратно
        меняющая(реверсирующая) направление вращения правого двигателя по
        внешнему сигналу. Это достигается переключением фаз одного из
        двигателей, а также переключением сигналов с датчиков Холла,
        установленных на двигателе. Что позволяет задавать движение вперед и
        назад из второго режима работы гироскутера.</p>
      <p>Здесь и далее, при управлении имитируемый угол наклона платы гироскопа
        считается управляющим воздействием, пропорциональным скорости
        соответствующего двигателя.</p>
      <p>Общая структурная схема робота после модификаций имеет вид,
        представленный на рисунке 22.<img style="width: 628px; height: 292px;" longdesc="4"
          title="4" alt="4" src="img/chapter4_4.png"></p>
      <h3> </h3>
      <p>Рисунок 22 - общая структурная схема робота</p>
      <p>Схема алгоритма работы программы управления двигателями, представлена
        на рисунке 23.</p>
      <p><img style="width: 385px; height: 531px;" longdesc="5" title="5" alt="5"
          src="img/chapter4_5.png"></p>
      <p>Рисунок 23 - Схема алгоритма работы программы управления двигателями</p>
      <p>Электрическая принципиальная схема коммутатора, реверсирующего правый
        двигатель по внешнему управляющему сигналу, представлена на рисунке.</p>
      <p><img style="width: 402px; height: 420px;" longdesc="7" title="7" alt="7"
          src="img/chapter4_7.png"></p>
      <br>
      <p>Рисунок 24 - Эектрическая принципиальная схема коммататора</p>
      <p>Внешний вид платы коммутатора представлен на рис. (вставить фото) .</p>
      <h3><br>
      </h3>
      <h3>4.1.3 Разработка протокола управления скоростью двигателей</h3>
      <p>Для передачи команд управления с бортовой ЭВМ на плату управления
        двигателями робота разработан протокол. Протокол использует интерфейс
        UART RS-232.</p>
      <table style="width: 100%" border="1">
        <tbody>
          <tr>
            <td>Бодрейт</td>
            <td>9600</td>
          </tr>
          <tr>
            <td>Количество информации в одном пакете </td>
            <td>8 бит</td>
          </tr>
          <tr>
            <td><br>
            </td>
            <td><br>
            </td>
          </tr>
          <tr>
            <td><br>
            </td>
            <td><br>
            </td>
          </tr>
        </tbody>
      </table>
      <p><br>
      </p>
      <p>Команды управления для моторов кодируется однобайтовым числом&nbsp;0 -
        255.</p>
      <p>Диапазон изменения скорости для левого и правого моторов: от -7 до +7.</p>
      <p> Для левого мотора используются 4 старших разряда числа, для правого
        мотора - 4 младших разряда числа.</p>
      <p>Рассмотрим 4 старших разряда для левого мотора:</p>
      <p>1111 - представление в двоичной системе счисления.</p>
      <p>Самый старший бит задает направление вращения колеса, 1 - вперед, 0 -
        назад.</p>
      <p>При вращении вперед скорость задается остальными тремя битами, двоичным
        числом от 001 до 111, т.е. 7 скоростей вперед. 001 - самая медленная,
        111 - самая быстрая.</p>
      <p>Для задания положительной скорости вращения назад скорость задается,
        двоичным числом от 111 до 001 , т.е. 7 скоростей назад. 111 - самая
        медленная, 001 - самая быстрая.</p>
      <p>Тоже самое для второго мотора.</p>
      <p>Пример принятого байта:</p>
      <p>1000 1000 - оба колеса не двигаются.</p>
      <p>1111 1111 - оба колеса вперед, с максимальной скоростью.</p>
      <p>0111 0111 - оба колеса назад, с минимальной скоростью.</p>
      <p>1001 0111 - левое колесо вперед с минимальной скоростью, правое назад с
        минимальной скоростью.</p>
      <p>0110 1101&nbsp; - левое колесо назад со скоростю 2, правое колесо
        вперед со скоростью 5.</p>
      <p>Управляющая команда 0000 0000 - инвертировать сигнал разрешения
        исполнения команд.</p>
      Комбинациии 10000000 и 00001000 - не определены и игнорируются.<br>
      <br>
      <h3>4.1.4 Бортовая ЭВМ</h3>
      <p>Мобильная платформа оснащена бортовой ЭВМ для управления и обработки
        информации с времепролетной камеры. Бортовая ЭВМ представляет собой
        ноутбук модели ASUS S300CA, внешний вид которого представлен на рис.<br>
        Выбор осуществлялся из необходимости размещения бортовой ЭВМ на
        мобильной платформе и мощности процессора установленного в ЭВМ, исходя
        из требований для использования реализации алгоритма SLAM.<br>
        В ЭВМ установлен процессор Intel Core i7, 4 Гб оперативной памяти и
        500Гб постоянной памяти.<br>
        Система технического зрения.<br>
        В качестве времепролетной (TOF) в задании на НИР была дана камера&nbsp;
        Microsoft Kinect 2.0, обладающая наибольшей коммерческой доступностью и
        простотой использования относительно других TOF-видеокамер.
        Характеристики Microsoft Kinect 2.0 приведены в таблице 2.<br>
        Microsoft Kinect 2.0 работает по принципу «range gated images»[]. В
        начальный момент времени включается освещение сцены инфракрасной
        подсветкой. Затвор инфракрасного приемника закрывается в момент времени
        t. Тогда объекты, расположенные дальше, чем t/(2c), где с – скорость
        света, не будут видны на камере . Свет не успевает отразиться от них до
        закрытия затвора. Точка, расположенная вплотную к камере будет
        освещаться всё время экспозиции t и иметь яркость I. Следовательно,
        любая точка экспозиции будет иметь яркость от 0 до I, и эта яркость
        будет репрезентацией расстояния до точки. Чем ярче точка – тем ближе
        объект. Для увеличения точности и дальности действия в Kinect 2.0
        используется последовательность вспышек с разным временем срабатывания
        затвора приемника[].</p>
      <h3>4.1.4 Времепролетная камера</h3>
      <p>В качестве времепролетной (TOF) в задании на НИР была дана камера
        Microsoft Kinect 2.0, обладающая наибольшей коммерческой доступностью и
        простотой использования относительно других TOF-видеокамер.
        Характеристики Microsoft Kinect 2.0 приведены в таблице 2.<br>
        Microsoft Kinect 2.0 работает по принципу «range gated images»[]. В
        начальный момент времени включается освещение сцены инфракрасной
        подсветкой. Затвор ифракрасного приемника закрывается в момент времени
        t. Тогда объекты, расположенные дальше, чем t/(2c), где с – скорость
        света, не будут видны на камере . Свет не успевает отразиться от них до
        закрытия затвора. Точка, расположенная вплотную к камере будет
        освещаться всё время экспозиции t и иметь яркость I. Следовательно,
        любая точка экспозиции будет иметь яркость от 0 до I, и эта яркость
        будет репрезентацией расстояния до точки. Чем ярче точка – тем ближе
        объект. Для увеличения точности и дальности действия в Kinect 2.0
        используется последовательность вспышек с разным временем срабатывания
        затвора приемника[].</p>
      <br>
      <h2>4.2 Программное обеспечение для реализации алгоритмов</h2>
      <p> fdfd</p>
      <p><!--Диссертация 3 стр 23-->Существуют<br>
        библиотеки<br>
        и<br>
        программные<br>
        пакеты,<br>
        помогающие<br>
        разработчику сэкономить силы и время при разработке программного<br>
        обеспечения (ПО) для робота. К ПО для разработки робототехнических
        систем<br>
        предъявляются следующие требования:<br>
         ПО должна позволять разработчику создавать для решения задачи<br>
        вспомогательные модули, которые могут быть тесно связаны с другими<br>
        модулями, внешними библиотеками и т. д. При этом процесс создания<br>
        программы должен быть максимально упрощен, чтобы заниматься<br>
        решением поставленной задачи, а не создания своего собственного<br>
        менеджера пакетов.<br>
         Так как в ходе работы робототехнической системы, на одной машине<br>
        может<br>
        быть<br>
        запущено<br>
        более<br>
        десятка<br>
        тесно<br>
        взаимодействующих<br>
        процессов, ПО должна взять на свои плечи заботу о контроле этого<br>
        взаимодействия, максимально упростив жизнь разработчику.<br>
         Реализации алгоритмов. Сложные системы могут выполнять множество<br>
        функций, например: определение координат ПА, создание карты<br>
        помещения<br>
        на<br>
        основе<br>
        данных<br>
        датчиков,<br>
        автономная<br>
        навигация,<br>
        планирование и т. д. Если реализация алгоритмов не является основной<br>
        целью, то лучше воспользоваться готовыми, максимально совместимыми<br>
        решениями.<br>
        В силу перечисленных выше причин, было решено использовать ПО ROS<br>
        (Robot Operating System), уже не раз упомянутое до этого. Далее будет<br>
        рассмотрены основные принципы работы этого ПО.<br>
        4.1. Robotic Operating System.<br>
        ROS – это фреймворк для программирования роботов, предоставляющий<br>
        функциональность для распределённой работы. ROS был первоначально<br>
        23разработан в 2007 году под названием switchyard в Лаборатории
        Искусственного<br>
        Интеллекта Стэнфордского Университета. В 2008 году развитие продолжается
        в<br>
        Willow Garage, научно-исследовательском институте/инкубаторе
        робототехники,<br>
        совместно с более чем двадцатью сотрудничающими институтами.<br>
        ROS обеспечивает стандартные службы операционной системы, такие как:<br>
        аппаратную абстракцию, низкоуровневый контроль устройств, реализацию<br>
        часто используемых функций, передачу сообщений между процессами, и<br>
        управление пакетами. ROS основан на архитектуре графов, где обработка<br>
        данных происходит в узлах, которые могут получать и передавать сообщения<br>
        между собой. Библиотека ориентирована на Unix-подобные (Ubuntu) системы,<br>
        однако сейчас активно разрабатывается поддержка платформ Windows и
        MacOS.<br>
        Основные достоинства ROS :<br>
         архитектура операционной системы;<br>
         набор поддерживаемых сообществом пакетов (ros-pkg);<br>
         бесплатен для использования в коммерческих и исследовательских<br>
        проектах.<br>
        4.2. Понимание файловой системы ROS. Концепция графов.<br>
        Основной единицей файловой системы является пакет (package). Каждый<br>
        пакет содержит библиотеки, исполняемые файлы, скрипты, и т. д. Для
        каждого<br>
        пакета существует свой манифест (manifest), в котором есть краткое
        описание<br>
        пакета, зависимости между пакетами, и различная мета информация, такая
        как<br>
        версия пакета, лицензия и т.д.<br>
        Введем несколько понятий:<br>
        <br>
        Узел (Node) — некоторый исполняемый процесс, который использует ROS<br>
        для связи с другими узлами.<br>
        24<br>
        Сообщения (Messages) – специальный тип данных ROS используемый<br>
        узлом для публикации или подписки на топики.<br>
        <br>
        Топики (Topics) — узлы могут подписываться на топик, чтобы получать<br>
        сообщения, или публиковать в топик, чтобы отправлять сообщения.<br>
         Мастер (Master) — имя сервиса для ROS.<br>
         rosout – эквивалент stdout/srderr.<br>
        В ROS существует множество инструментов, помогающих программисту в<br>
        процессе разработки и обработки ошибок, можно легко проследить как<br>
        взаимодействуют между собой различные процессы внутри ROS. Пакет Rviz<br>
        является частью ROS, а Gazebo — ROS совместим.<br>
        Рассмотрим пакет tf, который помогает разработчику упростить работу с<br>
        преобразованием<br>
        координат.<br>
        описывается с помощью<br>
        Конфигурация<br>
        робототехнической<br>
        системы<br>
        систем координат, связанных с различными частями<br>
        робота. tf наблюдает за положением систем координат, и позволяет
        определить в<br>
        любой момент времени (от некоторого t=0 и до текущего момента времени)<br>
        положение и ориентацию одной системы координат относительно другой. Для<br>
        этого некоторый узел подписывается на (публикует в) топик tf, таким
        образом<br>
        получая необходимую информацию.<br>
        5. Разработка контроллера 4-колесного мобильного робота.<br>
        Для 4-колесного робота необходимо разработать контроллер, позволяющий<br>
        с помощью определенного оборудования (джойстик, клавиатура) передавать
        ПА<br>
        команды. В ограничениях нашей за</p>
      <!--Диссертация 3 конец--> <br>
      <br>
      <br>
      Для реализации разработанных алгоритмов выбран программный пакет ROS
      (Robot Operating System). Выбор ROS для разработки определён по следующим
      причинам – удобство разработки и использования, универсальность,
      модульность, открытый программный код, возможность использования готовых
      пакетов. Для ROS доступны удобные инструменты сбора информации с датчиков
      в процессе работы системы.<br>
      <br>
      <br>
      4.2.1 Robot Operating System<br>
      <a style="color: #cc0000;" href="%D0%94%D0%B8%D0%BF%D0%BB%D0%BE%D0%BC+%D0%91%D0%B0%D0%BB%D1%82%D0%B0%D1%88%D0%BE%D0%B2%D0%B0">ROS
        (Robot Operating System) [] – программный пакет для роботов с открытым
        исходным кодом (лицензия BSD). Он не заменяет операционную систему, но
        расширяет ее набором модулей, необходимых для управления РТС. </a><br>
      <a style="color: #cc0000;" href="%D0%94%D0%B8%D0%BF%D0%BB%D0%BE%D0%BC+%D0%91%D0%B0%D0%BB%D1%82%D0%B0%D1%88%D0%BE%D0%B2%D0%B0">Основной
        целью ROS является поддержка повторного использованиякода в
        робототехнических исследованиях и разработках. ROS состоит из двух
        частей: ядро ROS – минимально необходимый для работы набор инструментов,
        модулей и библиотек; и набор развиваемых пользователями пакетов, которые
        реализуют различные функции робототехники: работа с оборудованием,
        обработка информации, моделирование, навигация и многое другое.<br>
        Ядро ROS разработано так, чтобы как можно меньше зависеть от архитектуры
        конечной системы. Граф вычислений ROS представляет собой одноранговую
        сеть процессов (узлов в терминологии ROS), которые обрабатывают данные
        совместно. Узлы могут обмениваться данными несколькими способами: через
        системные сообщения (темы в терминологии ROS), сервисы или сервер
        параметров. Структура данных и логика обмена может быть любой. При
        старте узлы сообщают свои регистрационные данные мастер-узлу, который
        хранит регистрационную информацию. От него узлы могут получить
        информацию о других зарегистрированных узлах и наладить с ними связь
        напрямую через согласованный протокол обмена (наиболее распространен в
        ROS протокол TCPROS, в основе которого лежит TCP/IP). Мастер информирует
        узлы об изменениях в системе ROS, что позволяет динамически создавать
        соединения при старте новых узлов. Узлы могут располагаться на различных
        компьютерах, и топология системы может изменяться в процессе работы без
        необходимости перекомпиляции. В отличие от других решений, код ROS
        максимально гибкий - он не накладывает ограничений на тип приложений,
        использованные узлы, структуру связи узлов и цикл работы. <br>
        ROS не зависит от языка программирования, клиентские библиотеки уже
        реализованы для Python, C++, Lisp, существуют экспериментальные
        библиотеки для Java и Lua []. Такой подход позволяет ROS легко
        интегрироваться с различными архитектурами и строить системы различной
        сложности поверх нее.</a><br>
      <br>
      <br>
      <p> 4.2.2 Реализация алгоритма планирования пути<br>
        <a style="color: #cc0000;" href="Baltash"><br>
          Предложенный АМПП реализован на языке C++ с использованием средств,
          входящих в состав программного пакета ROS. На рисунке 8 приведена
          упрощённая блок-схема узлов ROS разработанной системы.</a></p>
      <p> На рисунке представлен результат работы алгоритма RTAB-Map</p>
      <p><br>
      </p>
      <!--Диссертация 3 стр 19-->
      <h3>4.3 Создание виртуальной модели мобильного робота и рабочего
        окружения. </h3>
      <p> Не всегда возможно найти реальное оборудование для исследований. Это
        связано в первую очередь с ценами ПА роботов, датчиков, например, цена
        высокоточный системы лазерных дальномера может доходить до запредельных
        цифр. Так же робототехнические системы являются тонко-настраиваемыми, и
        любая поломка может надолго отложить реальные исследования. Поэтому
        хорошее программное обеспечение, позволяющее визуализировать реальные<br>
        робототехнические системы, позволяют исследователям экономить денежные и
        временные ресурсы. Далее, в работе проведен обзор существующих решений
        для визуализации роботов и рабочего окружения (РО).</p>
      <p>4.3.1. Средства визуализации роботов и рабочей среды.</p>
      <p>В качестве средств визуализации робота и РО были использованы пакеты
        Gazebo и Rviz, которые являются частью пакета Robot Operating System,
        использующийся в данной работе.</p>
      <p>Gazebo позволяет моделировать физические свойства мобильного робота и
        РО, показания различных датчиков и т. д. Rviz позволяет создавать
        виртуальную модель робота и визуализировать данные датчиков, карты,
        маршруты.</p>
      <p>3.2. Ограничения рабочего окружения.<br>
        В качестве основного датчика был выбран 2D лазерный дальномер, что<br>
        накладывает некоторые ограничения на рабочую среду робота:<br>
         поверхность рабочей среды является плоскостью;<br>
         луч лазера параллелен поверхности среды, датчик неподвижно закреплен<br>
        на роботе;<br>
         высота препятствий превосходят высоту, на которой находиться лазерный<br>
        дальномер;<br>
         поверхности объектов среды не являются зеркальными и прозрачными<br>
        поверхностями, гарантируется надежность измерения датчика.<br>
        Введенные ограничения позволяют свести нашу задачу, к задачи<br>
        автономной навигации на плоскости. Упомянутый выше Robotic Operating<br>
        System имеет мощные программные средства, позволяющие решить эту задачу.</p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p>3.3. Виртуальная модель робота.<br>
        Была создана виртуальная модель 4-колесного робота с параметрами<br>
        указанными в таблице 3.</p>
      <p><br>
      </p>
      <h3>Разработка системы автономной навигации.</h3>
      <p>В этой работе использованы возможности ROS, которая предлагает решение
        этой задачи с помощью пакета move_base ([19]). Далее в работе
        рассмотрены свойства и организация этого пакеты управления. Пакет
        move_base.<br>
        Рис 7. Схема конфигурации пакета move_base.<br>
        Рассмотрим компоненты этой схемы:<br>
         Карта (map_server). Узел map_server подает на вход некоторую карту РО,<br>
        эта карта будет использована для построения global_costmap – глобальной<br>
        карты препятствий, по которой затем алгоритм будет решать в каких<br>
        точках стоит прокладывать маршрут.<br>
         Одометрия (odometry source). Необходимо, чтобы через tf модуль мог<br>
        достать преобразование odom → base_link, где base_link — система<br>
        координат связанная с роботом, а odom — система координат, в которой<br>
        происходит движение ПА.<br>
         Координаты мобильного робота (amcl, sensor transforms). Необходимо,<br>
        чтобы с помощью некоторого алгоритма (например, адаптивного метода<br>
        Монте-Карло — amcl, [29],[30]), который через tf предоставляет группу<br>
        последовательных преобразований координат: map → odom → base_link.<br>
        В этой работе, чтобы уменьшить вычислительные затраты, был<br>
        использован пакет fake_localization, который предоставляет те же<br>
        29преобразования в tf, что и amcl, но в отличии от последнего, он<br>
        использует данные о положении робота на карте из симуляции, и как<br>
        следствие экономит вычислительные ресурсы.<br>
         Данные датчиков (sensor sources), которые будут использованы для<br>
        построения local_costmap, которые будут использованы программой для<br>
        обеспечения движения ПА по маршруту.<br>
         global_planner.<br>
        который<br>
        Существует<br>
        используется<br>
        интерфейс<br>
        планировщиками<br>
        nav_core::BaseGlobalPlanner,<br>
        пути.<br>
        Один<br>
        из<br>
        таких<br>
        планировщиков — navfn. Он использует алгоритм Дейкстры для расчета<br>
        минимального пути из начальной точки в конечную.<br>
         local_planner.<br>
        nav_core::BaseLocalPlanner<br>
        предоставляет<br>
        интерфейс<br>
        используемый локальными планировщиками. base_local_planner — один<br>
        из плагинов использующих этот интерфейс. Этот пакет предоставляет<br>
        реализации методов TRA (Trajectory Rollout approach) и DWA(Dynamic<br>
        Window approach) для локальной навигации робота на плоскости.<br>
        Принимая на вход маршрут и карту препятствий (costmap), на выходе<br>
        выдает скорость, которая затем передается контроллеру робота.<br>
        6.2. Поведение робота.<br>
        Рис 8. Схема поведения робота при восстановлении.<br>
        При<br>
        вызове<br>
        move_base<br>
        будет<br>
        пытаться<br>
        30<br>
        обеспечить<br>
        достижениепоставленной пользователем цели в пределах некоторой
        установленной<br>
        пользователем<br>
        погрешности.<br>
        В<br>
        конечном<br>
        итоге,<br>
        move_base<br>
        сообщит<br>
        пользователю о том, что цель достигнута или же поставленная цель<br>
        недостижима. Если робот застревает, то модуль переходит в режим<br>
        восстановления. По умолчанию, move_base выполнит следующие действия,<br>
        чтобы восстановить движение робота:<br>
        1. препятствия за пределами заданной пользователем области будут удалены<br>
        с карты робота; ,<br>
        2. если возможно, робот будет выполнять вращение на месте, чтобы<br>
        очистить пространство перед ним;<br>
        3. если это тоже не удается, робот полностью очистит область карты, в<br>
        которой робот может вращаться;<br>
        4. после этого он продолжит свое вращение.<br>
        Если ничего из вышеуказанного не поможет, цель будет считаться<br>
        недостижимой и её выполнение будет прервано. Пользоват</p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p><br>
      </p>
      <!--Балташов-->
      <p>3.7 Стек навигации ROS<br>
        В качестве алгоритма 2D навигации выбран стек навигации ROS [55].<br>
        Стек навигации является концепцией построения графа узлов ROS для<br>
        реализации алгоритмов 2D навигации и набор готовых узлов, реализующих
        эту задачу. На рисунке 14 приведена схема узлов стека навигации ROS. </p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p>Рисунок 14 - Граф узлов стека навигации ROS<br>
        Стек навигации ROS состоит из пяти элементов – глобальный<br>
        планировщик (global_planner), локальный планировщик (local_planner),<br>
        алгоритм построения глобальной карты (global_costmap), алгоритм
        построения локальной карты (local map) и алгоритм восстановления
        (recovery_behaviors).<br>
        Алгоритм построения глобальной карты, отвечает за построение<br>
        вспомогательной карты необходимой для глобального планировщика пути. В
        качестве такого планировщика выбран costmap_2d [56], он строит весовую
        сеточную 2D карту на основе 2D сеточной карты, полученной, например,
        алгоритмом SLAM, и датчиков робота с учётом геометрических ограничений
        робота. В использованном алгоритме учитывается только радиус круга,
        обеспечивающий поворот робота без коллизий. Ячейки полученной карты
        содержат значения, отражающие возможность центра робота находиться в
        данной точке от явной коллизии до свободного пространства. Алгоритм
        построения локальной карты выполняет<br>
        аналогичную функцию, но так как локальная карта используется для объезда
        динамических препятствий, то она строится только на основании данных с
        датчиков, имеет небольшой фиксированный размер (в данной работе размер
        динамического окна составляет 4x4 м) и обновляется с большей в несколько
        раз частотой, чем глобальная карта. В качестве алгоритма построения
        локальной карты 37использовался тот же алгоритм costmap_2d, что и для
        построения глобальной<br>
        карты, но с другими настройками. Глобальный планировщик решает задачу
        поиска оптимального пути движения робота к заданной целевой точке на
        основании глобальной карты. В данном случае используется узел
        global_planner [57], реализующий алгоритмы Дейкстры и A* поиска
        глобального пути на сеточной весовой карте. Локальный планировщик
        отвечает за движение робота вдоль глобального<br>
        пути с учётом особенностей локомоции робота и возникающих динамических
        препятствий на пути движения. В текущей разработке используется алгоритм
        dwa_local_planner [58]. Принцип его работы заключается в переборе всех
        возможных управляющих комбинаций линейной и угловой скорости в
        определённых пределах с заданным<br>
        шагом.<br>
        Среди всех вариантов отбрасываются те варианты, которые приведут к
        столкновению робота с окружающими объектами при движении с
        соответствующей скоростью в течение некоторого времени. Из оставшихся
        вариантов выбирается тот, чей вес на основе значений локальной карты и
        близости к глобальному пути меньше чем у остальных.<br>
        Алгоритм восстановления – это набор действий, которые совершает<br>
        робот в случае, если локальный или глобальный путь найти не удалось. В<br>
        текущей работе использовалась очистка локальной карты и полный поворот
        робота на месте. Такой алгоритм восстановления позволяет избавить
        построенные карты от ошибок, возникших от быстродвижущихся динамических
        препятствий.</p>
      <p><br>
      </p>
      <p><br>
      </p>
      <h3> 3.4 Алгоритм поиска пути</h3>
      <p>global_planner.<br>
        который<br>
        Существует<br>
        используется<br>
        интерфейс<br>
        планировщиками<br>
        nav_core::BaseGlobalPlanner,<br>
        пути.<br>
        Один<br>
        из<br>
        таких<br>
        планировщиков — navfn. Он использует алгоритм Дейкстры для расчета<br>
        минимального пути из начальной точки в конечную.<br>
         local_planner.<br>
        nav_core::BaseLocalPlanner<br>
        предоставляет<br>
        интерфейс<br>
        используемый локальными планировщиками. base_local_planner — один<br>
        из плагинов использующих этот интерфейс. Этот пакет предоставляет<br>
        реализации методов TRA (Trajectory Rollout approach) и DWA(Dynamic<br>
        Window approach) для локальной навигации робота на плоскости.<br>
        Принимая на вход маршрут и карту препятствий (costmap), на выходе<br>
        выдает скорость, которая затем передается контроллеру робота.</p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p>Для реализации был использован алгоритм А*. Он является алгоритмом
        поиска кратчайшего пути на графе. Этот эвристический поиск сортирует все
        узлы по стоимости наилучшего маршрута, идущего через этот узел. Он
        сочетает в себе учет длины предыдущего пути из алгоритма Дейкстры с
        эвристикой из алгоритма «лучший-первый». A* имеет множество интересных
        свойств. Он гарантированно находит кратчайший путь до тех пор, пока
        эвристическое приближение является допустимым, т.е. никогда не превышает
        действительного оставшегося<br>
        расстояния до цели. В отличие от других, этот алгоритм наилучшим образом
        использует эвристику, обрабатывая наименьшее число узлов.<br>
        Чтобы воспользоваться этим алгоритмом, необходимо отобразить карту
        помещения на граф. Для карты-сетки такое отображение является
        стандартным, при этом карта представляет собой восьмисвязный граф,
        вершины которого находятся в центре каждой ячейки, а ребрами<br>
        являются переходы к соседним; каждая ячейка может быть «свободной»,
        «занятой», а также обладать некоторой стоимостью перехода через нее.</p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p>Специальные алгоритмы поиска кратчайшего пути. В случае, когда карта
        представлена в виде сетки, ее ячейки являются вершинами взвешенного
        графа, а его ребра определяют связность смежных узлов. В качестве
        примеров можно привести алгоритм A* (A-звезда) и его модификации.<page size="A4"></page></p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p>Принцип работы алгоритма А*.<br>
        Пусть имеется участок карты, показанный на Рис. 3.4. Зеленая клетка
        (слева) обозначает<br>
        положение робота, красная клетка (справа) – целевую точку. Серые клетки
        представляют<br>
        препятствия. Задача поиска пути сводится к определению
        последовательности клеток, через<br>
        центры которых робот проедет за кратчайшее время. Принимаем допущение,
        что время<br>
        движения робота по свободным клеткам прямо пропорционально длине пути.<br>
        Рис. 3.4. Исходное состояние алгоритма поиска пути<br>
        Центры клеток являются вершинами графа. Вершины могут находиться в
        «открытом»<br>
        списке, в «закрытом», а также вне этих списков. В исходном состоянии оба
        списка пусты.<br>
        «Открытый» список содержит вершины, которые необходимо обработать,
        «закрытый» список<br>
        содержит уже обработанные вершины. У каждой вершины (клетки), кроме
        начальной, есть<br>
        «родительская» – это вершина, в которой проводился поиск на предыдущей
        итерации. Также<br>
        каждой вершине присваивается стоимость – относительная величина
        сложности пути.<br>
        В данной реализации алгоритма поиск начинается с целевой вершины и
        заканчивается в<br>
        вершине, где находится робот. Итак, начинаем с вершины F и проверяем
        соседние клетки до<br>
        тех пор, пока не встретится вершина S. Инициализация поиска состоит из
        следующих этапов.<br>
        1. Добавляем вершину F в «открытый» список.<br>
        2. Ищем доступные «свободные» клетки, граничащие с данной, игнорируя
        «занятые».<br>
        Добавляем их также в «открытый» список. Для каждой из этих клеток
        сохраняем<br>
        направление на «родительскую» клетку.<br>
        3. Удаляем вершину F из «открытого» списка и помещаем в «закрытый».<br>
        Результат этих операций представлен на Рис. 3.5. Целевая вершина F
        теперь находится в<br>
        «закрытом» списке. Соседние вершины, в свою очередь, попали в «открытый»
        список.91<br>
        Указатель в этих клетках показывает направление на «родительскую»
        вершину, которой в<br>
        данном случае является F.<br>
        Рис. 3.5. Первый шаг работы алгоритма А*<br>
        Следующий шаг – выбор одной из соседних клеток в открытом списке и
        практически<br>
        повторить вышеописанный процесс. Чтобы определиться, с какой вершины
        начать, необходимо<br>
        отсортировать все вершины из «открытого» списка по стоимости. Стоимость
        вершины<br>
        определяется следующим выражением:<br>
        F  G  H ,<br>
        (3.3)<br>
        где G – стоимость передвижения от данной клетки к целевой точке, следуя
        по уже найденному<br>
        пути, H – примерная стоимость передвижения от стартовой точки S до
        текущей, она является<br>
        эвристической функцией текущей вершины. Оценка стоимости H является
        предположением<br>
        оставшейся длины пути, т.к. в действительности она неизвестна и зависит
        от расположения<br>
        препятствий на карте. Рассмотрим подробнее вычисление стоимости F.<br>
        Как описано выше, G является стоимостью передвижения от текущей клетки
        до целевой,<br>
        используя найденный к ней путь. Расстояние между вершинами по диагонали
        больше, чем<br>
        расстояние по горизонтали или вертикали в<br>
        2  1, 414 раз. Чтобы упростить вычисления,<br>
        округлим это значение до 1,4. Тогда стоимость горизонтальных и
        вертикальных перемещений<br>
        примем за 10, а стоимость диагональных – 14. Это позволяет избавиться от
        вычисления<br>
        квадратного корня и операций над числами с плавающей запятой. Так как мы
        определяем<br>
        стоимость G вдоль пути, начинающегося от текущей точки, способ
        установить ее состоит в том,<br>
        чтобы взять значение G «родительской» вершины и прибавить 10 или 14, в
        зависимости от<br>
        расположения<br>
        текущей<br>
        клетки<br>
        относительно<br>
        «родительской»,<br>
        ортогонального<br>
        или<br>
        диагонального, соответственно, после чего домножив на коэффициент k G
        стоимости пути в этой<br>
        клетке.<br>
        Стоимость H может быть вычислена множеством способов. В данной работе
        используется<br>
        один из наиболее распространенных методов оценки расстояния – метод
        «укороченной92<br>
        диагонали», использующий расстояние по горизонтали и вертикали от
        стартовой вершины S до<br>
        текущей. Введем обозначение:<br>
         x  x C  x S ,  y  y C  y S ,<br>
        где<br>
        x S , y S , x C , y C<br>
        –<br>
        координаты<br>
        стартовой<br>
        и<br>
        текущей<br>
        (3.4)<br>
        вершины,<br>
        соответственно,<br>
         x ,  y – расстояние по горизонтали и вертикали. Тогда эвристическая
        функция H данного<br>
        метода имеет следующий вид:<br>
        H  14  min   x ,  y   10   max(  x ,  y )  min   x ,  y 
        <br>
        (3.5)<br>
        С помощью эвристики алгоритм «пытается» оценить оставшееся расстояние
        вдоль пути,<br>
        который в общем случае идет не по прямой, но требуется не переоценить
        это расстояние, иначе<br>
        найденный путь может быть субоптимальным. Использованный здесь метод
        гарантирует<br>
        нахождение оптимального пути.<br>
        Суммарная стоимость F вычисляется путем сложения стоимостей G и H.
        Результаты<br>
        первого шага поиска пути проиллюстрированы на Рис. 3.5. Значения F, G и
        H записаны в<br>
        каждой клетке. F находится в левом верхнем углу, G – в левом нижнем, а H
        – в правом верхнем.<br>
        Как видно из рисунка, стоимости вершин посчитаны верно.<br>
        Для продолжения поиска выбираем вершину с наименьшей стоимостью F из
        всех вершин,<br>
        находящихся в «открытом» списке. Затем с выбранной вершиной производим
        следующие<br>
        действия.<br>
        1. Удаляем ее из «открытого» списка и добавляем в «закрытый» список.<br>
        2. Проверяем все соседние клетки. Игнорируем те, которые находятся в
        закрытом списке<br>
        или «заняты», остальные добавляем в «открытый» список, если они там ещё
        не<br>
        находятся. Устанавливаем направление на выбранную вершину у всех
        соседних<br>
        клеток.<br>
        3. Если соседняя клетка уже находится в открытом списке, проверяем
        стоимость пути<br>
        через эту вершину, т.е. сравниваем значения стоимости G этих клеток.
        Если при<br>
        использовании этой клетки стоимость G выше, чем при использовании
        текущей<br>
        клетки, то ничего не предпринимаем. В противном случае меняем
        «родительскую»<br>
        вершину на текущую. Затем вычисляем стоимости F и G этой клетки.<br>
        Проследим дальнейшую работу алгоритма на данном примере. На Рис. 3.5
        вершина с<br>
        наименьшей стоимостью F=40 находится слева от целевой точки. Выбираем ее
        в качестве<br>
        текущей. Слева от этой точки препятствия, игнорируем их. Вершина справа
        («родительская»)<br>
        уже находится в «закрытом» списке, поэтому ее тоже игнорируем. Остальные
        соседние клетки<br>
        имеют меньшую стоимость G, чем суммарная стоимость перехода через
        текущую клетку,<br>
        значит, ничего не нужно менять.93<br>
        Выбираем следующую по стоимости вершину. В данном случае их две, с F=48.
        Начинать<br>
        можно с любой, например с последней по списку (на Рис. 3.5 верхняя из
        них). Также<br>
        игнорируем «занятые» и «закрытые» клетки. Выше текущей находятся еще не
        обработанные<br>
        вершины, поэтому добавляем их в «открытый» список и вычисляем стоимости
        (Рис. 3.6).<br>
        Клетка над препятствием не добавляется для проверки, так как для
        перехода в нее необходимо<br>
        срезать угол препятствия, что в нашем случае не допускается, т.к. робот
        имеет определенные<br>
        размеры.<br>
        Рис. 3.6. Второй шаг алгоритма А*<br>
        Повторяем вышеописанные процедуры со всеми вершинами из «открытого»
        списка до тех<br>
        пор, пока в открытый список не попадет стартовая точка S, либо пока в
        «открытом» списке не<br>
        останется ни одной вершины, в этом случае пути, соединяющего стартовую
        точку с целевой, не<br>
        существует. В данном примере результат такой прогонки выглядит, как
        показано на Рис. 3.7.<br>
        Отметим, что алгоритм огибал препятствие одинаково с двух сторон, ввиду
        симметричности<br>
        используемой карты. Достижение стартовой точки именно через верхние
        клетки объясняется<br>
        способом разрешения неопределенностей, подобных той, что возникла на
        втором шаге<br>
        алгоритма.<br>
        Рис. 3.7. Последний шаг алгоритма А*94<br>
        В результате выполнения нескольких итераций рекурсивной обработки вершин
        имеем<br>
        карту, ячейки которой содержат стоимости пути до целевой точки, а также
        направления,<br>
        указывающие на клетки, стоимость которых понижается по мере продвижения
        по этим<br>
        направлениям. Двигаясь от стартовой точки по этим направлениям,
        достигаем целевой точки –<br>
        это и будет искомый оптимальный путь. На Рис. 3.8 этот путь показан
        кругами в центре клеток,<br>
        которые необходимо пройти для достижения цели. Нужно заметить, что углы
        вокруг<br>
        препятствия не срезаны, что позволяет более аккуратно его объехать.<br>
        Рис. 3.8. Результат работы алгоритма А* – оптимальный путь</p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p> Алгоритм поиска пути используется как на этапе составления 3D карты
        окружающей неизвестной среды, так и на этапе автономного перемещения в
        заданную точку на построенной карте.</p>
      <p>На выходе алгоритма получаем последовательность точек (узлов 2D графа).</p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p>Рисунок 12 – Блок-схема работы алгоритма поиска пути в глубину <br>
      </p>
      <h3> 3.5 Алгоритм планирования траектории движения робота</h3>
      <p>диссертация 1 глава 3</p>
      <p>В данной работе задача формулируется следующим образом. Пусть имеется
        карта помещения и кусочно-линейная траектория, построенная от текущего
        положения мобильного робота до целевой точки. Положение робота
        определяется при помощи алгоритма SLAM.</p>
      <p>Необходимо провести робот вдоль этой траектории, с учетом следующих
        условий:</p>
      <p>1) траектория планируется синхронно с получением скана в режиме
        реального времени;</p>
      <p>2) управление мобильным роботом осуществляется с помощью поступательной
        скорости движения и скорости поворота; </p>
      <p>3) допускается незначительное отклонение от спланированной траектории с
        целью снижения времени достижения цели;</p>
      <p>4) конечные скорости мобильного робота в целевой точке должны равняться
        нулю, то есть робот должен остановиться;</p>
      <p>5) курсовой угол робота в целевой точке не имеет значения.<br>
        Для реализации управления был выбран метод эффективного пути. Краткое
        описание и обоснование выбора этого метода изложено в первой главе
        настоящей работы. Напомним, понятие «эффективный путь» введено в [49] и
        означает отрезок, соединяющий текущее положение робота с текущей опорной
        точкой. Опорная точка – это точка на траектории, к которой робот
        стремится в текущий момент. По сути, результатом работы метода является
        выбор координат опорной точки на траектории. К недостатку этого способа
        управления следует отнести отклонение траектории робота от
        спланированного маршрута и возможность столкновения со статическими
        препятствиями. Поэтому в диссертации предложен способ корректировки
        опорной точки таким образом, чтобы избежать столкновений</p>
      <p><br>
      </p>
      <p>диссертация 1 глава 1.4.1</p>
      <p>1.4.1. Общие принципы управления на траекторном уровне<br>
        Процесс управления роботом при движении по траектории можно представить
        в виде<br>
        функциональной схемы (Рис. 1.7). Траектория, спланированная алгоритмом
        поиска пути,<br>
        подается на вход системы. Блок вычисления текущей цели определяет точку
        на траектории, к<br>
        которой в данный момент движется робот. Затем заданное положение
        сравнивается с текущим,<br>
        и на вход регулятора подается сигнал ошибки. Он определяет необходимое
        управление, которое<br>
        приведет робот в заданное положение.<br>
        Траектория<br>
        Реальное положение<br>
        Вычисление<br>
        текущей цели<br>
        Заданное<br>
        положение<br>
        Блок<br>
        сравнения<br>
        Ошибка<br>
        Регулятор<br>
        Управление<br>
        Мобильный<br>
        робот<br>
        Реальное положение<br>
        Рис. 1.7. Функциональная схема управления мобильным роботом<br>
        Рассмотрим подробнее возможные реализации каждого блока в данной схеме.
        Поиск пути<br>
        по карте-сетке дает кусочно-линейную траекторию. Существует несколько
        вариантов задания<br>
        текущей целевой точки для системы управления.</p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p>Метод динамического окна<br>
        В задаче управления движением современных мобильных роботов наиболее
        эффективно<br>
        показывает себя универсальный метод динамического окна [26], суть
        которого заключается в<br>
        выборе оптимального вектора скорости V r из допустимой области
        пространства скоростей,<br>
        которая получила название «динамическое окно»:</p>
      <p><br>
      </p>
      <p>Итак, при исследовании методов управления движением были получены
        следующие результаты.<br>
        1. Модифицированный метод эффективного пути работоспособен и достаточно<br>
        надежен, относительно прост в реализации, не требователен к
        вычислительным<br>
        ресурсам при малом числе динамических препятствий.<br>
        2. Использование метода динамического окна для управления мобильным
        роботом<br>
        показало, что робот может двигаться вдоль спланированной траектории, не<br>
        сталкиваясь со статическими и динамическими препятствиями. При этом
        время<br>
        прохождения практически не меняется при увеличении числа препятствий.
        Отметим<br>
        также, что метод является универсальным и позволяет использовать
        различные<br>
        критерии оптимальности.</p>
      <p> <br>
        <br>
        Рисунок 13 – Блок-схема алгоритма планирования траектории движения
        робота<br>
      </p>
      <h3> 3.6 Алгоритм формирования команд на движение робототехнической
        платформы</h3>
      <p>выа</p>
      <p></p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p><br>
      </p>
    </page>
  </body>
</html>
